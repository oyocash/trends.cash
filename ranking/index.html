<html>
<head>
  <title>Trends.cash - Popular Bitcoin SV apps (sorted by actions)</title>
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:creator" content="@pmitchev" />
  <meta name="twitter:title" content="Trends.cash - Popular Bitcoin SV apps (sorted by actions)" />
  <meta name="twitter:description" content="Ranking of popular Bitcoins SV apps sorted by performed actions" />
  <meta name="twitter:image" content="https://trends.cash/assets/images/logo-large.png" />
  <meta property="og:url" content="https://trends.cash" />
  <meta property="og:type"   content="website" />
  <meta property="og:title" content="Trends.cash - Popular Bitcoin SV apps (sorted by actions)" />
  <meta property="og:description" content="Ranking of popular Bitcoins SV apps sorted by performed actions" />
  <meta property="og:image" content="https://trends.cash/assets/images/logo-large.png" />

  <link rel="stylesheet" href="/assets/css/styles.css">
  <link rel="apple-touch-icon" sizes="57x57" href="/assets/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/assets/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/assets/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/assets/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/assets/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/assets/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/assets/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/assets/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192"  href="/assets/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/assets/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/assets/icons/favicon-16x16.png">
  <link rel="manifest" href="/assets/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/assets/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="bitcoin-address" content="1bGBx5H9NRmT3TbMHjXuUzo19CXmSfd6j">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.24.0/moment.min.js" integrity="sha256-4iQZ6BVL4qNKlQ27TExEhBN1HFPvAvAMbFavKKosSWQ=" crossorigin="anonymous"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.8.0/Chart.min.js" integrity="sha256-Uv9BNBucvCPipKQ2NS9wYpJmi8DTOEfTA/nH2aoJALw=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pikaday/1.8.0/pikaday.min.js" integrity="sha256-+B1vOR24Jpk4oWE/+SWu7AxoQqrqDT4SF+12bixBdjw=" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/bchaddrjs@0.4.4/dist/bchaddrjs-0.4.4.min.js"></script>
  <script src="/assets/js/loader.js"></script>
  <script src="/assets/js/loadVars.js"></script>
  <script src="/assets/js/common.js"></script>
  <script src="/assets/js/bob.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pikaday/1.8.0/css/pikaday.min.css" integrity="sha256-+RIb33VoW3hHdfmp0+G4FrGAxzlKBXiwo6thzduwZdU=" crossorigin="anonymous" />
</head>
<body>
  <noscript>Ranking of popular Bitcoins SV apps sorted by performed actions</noscript>
  <div id="app" class="container">
    <div id="nav"></div>
      <div class="grid" id="loading">
        <div class="s_results">
          <div class="n_results">
            Loading...
          </div>
        </div>
      </div>
      <div class="grid" id="error">
        <div class="s_results">
          <div class="n_results">
            Error occured while loading. <a href="javascript:void(0)" onClick="window.location.reload();">Try again</a>
          </div>
        </div>
      </div>
      <div class="grid chartGrid" id="loaded">
        <div class="chartSection">
          <div class="chartNav">
            <div class="chartNavLeft">Zoom:
              <button class="periodButton" value="1">1d</button>
              <button class="periodButton" value="7">7d</button>
              <button class="periodButton" value="30">1m</button>
              <button class="periodButton" value="90">3m</button>
            </div>
            <div class="chartNavCenter"></div>
            <div class="chartNavRight">
              From: <input type="text" name="startDateForm" id="startDateForm" title="Search date start" placeholder="YYYY-MM-DD" disabled/>
              To: <input type="text" name="endDateForm" id="endDateForm" title="Search date end" placeholder="YYYY-MM-DD"/>
            </div>
          </div>
          <canvas id="myChart"></canvas>
        </div>

        <div class="resultTable">
          <div class="resultTable-container resultTable-separator">
            <div class="resultTable-title">
              Ranking by performed actions
            </div>
          </div>
          <div id="tableContent"></div>
        </div>
      </div>
    <div id="footer"></div>
  </div>

<script language='javascript'>
  // initiate loading
  document.getElementById("loading").style.display = "block";
  document.getElementById("error").style.display = "none";
  document.getElementById("loaded").style.display = "none";

  var itemsOnChart = 10
  var chartDataUnordered = []
  var chartDataFull = []
  var chartDataSliced = []

  // populate period
  var periodInput = parseInt(getUrlVars()["period"]) || window.rankingPeriodDefault
  // populate date
  var dateTimestamp, dateForm
  var dateInput = getUrlVars()["date"] || 0
  if (parseInt(dateInput) && parseInt(dateInput) !== 0) {
    let dateReal = new Date(Date.UTC(dateInput.substring(0,4), parseInt(dateInput.substring(4,6)) - 1, dateInput.substring(6,8), 23, 59, 59, 0))
    dateTimestamp = parseInt(dateReal.getTime() / 1000) + 1
    dateForm = dateReal.toISOString().substring(0, 10)
  } else {
    dateTimestamp = parseInt(new Date().getTime() / 1000)
    dateForm = new Date().toISOString().substring(0, 10)
  }
  document.getElementById('endDateForm').value = dateForm
  var startDateTimestamp = dateTimestamp - (periodInput * 24 * 60 * 60)
  var startDateForm = new Date(startDateTimestamp * 1000).toISOString().substring(0, 10)
  document.getElementById('startDateForm').value = startDateForm
  // create chart
  var ctx = document.getElementById('myChart').getContext('2d');
  ctx.canvas.width = 400;
  ctx.canvas.height = 300;
  var cfg = {
    type: 'pie',
    data: {
      datasets: []
    },
		options: {
			responsive: true
		}
  }
  var myChart = new Chart(ctx, cfg);
  var picker = new Pikaday(
  {
      field: document.getElementById('endDateForm'),
      firstDay: 1,
      minDate: new Date(2009, 01, 03),
      maxDate: new Date()
  });

  document.addEventListener("DOMContentLoaded", function() {
    // on date change
    document.getElementById('endDateForm').addEventListener("change", function() {
      changeEndDate("ranking", periodInput, document.getElementById('endDateForm').value)
    })
    // on period button click
    let periodButtons = document.getElementsByClassName('periodButton');
    for(let i=0; i<periodButtons.length; i++){
      if (parseInt(periodInput) === parseInt(periodButtons[i].value)) {
        periodButtons[i].classList.add("active")
      }
      periodButtons[i].addEventListener("click", function() {
        periodInput = periodButtons[i].value
        changeRoute("ranking", periodInput, dateInput)
      })
    }
    loadHead()
    loadNav().then(function(r) {
      navSearchPerformed(window.searchPeriodDefault, 0)
    })
    loadFooter()

    var getActionsChartQuery =  function (queryMatch, i) {
      var query = {
      	"v": 3,
      	"q": {
      		"aggregate": [{
      				"$unwind": "$out"
      			},
      			{
      				"$unwind": "$out.tape"
      			},
      			{
      				"$match": queryMatch
      			},
      			{
      				"$unwind": "$out.tape.cell"
      			},
            {
              "$match": {
                "out.tape.cell.i": i
              }
            },
      			{
      				"$group": {
      					"_id": "$out.tape.cell.b",
      					"count": {
      						"$sum": 1
      					}
      				}
      			}
      		],
      		"limit": 100,
      		"sort": {
      			"count": -1
      		}
      	}
      }
      return query
    }

    var getActionsChartData = function() {
      let urlType = {}
      let requests = []
//      for (let i = periodInput; i > 0; --i) {
//        let beginTimestamp = dateTimestamp - (i * 24 * 60 * 60)
//        let endTimestamp = dateTimestamp - ((i - 1) * 24 * 60 * 60)
      for (let i = periodInput * 12; i > 0; --i) {
        let beginTimestamp = dateTimestamp - (i * 2 * 60 * 60)
        let endTimestamp = dateTimestamp - ((i - 1) * 2 * 60 * 60)

        // get vanilla protocol count
        var queryMatch = {}
        queryMatch['$and'] = []
        queryMatch['$and'].push({"out.tape.cell": {"$all": [{"$elemMatch": {"i": 0, "s": {"$exists": true, "$ne": ""}}}, {"$elemMatch": {"i": 1, "s": {"$exists": true, "$ne": ""}}}]}})
        queryMatch['$and'].push({'blk.t': {'$gte': beginTimestamp, '$lte': endTimestamp}})
        var query = getActionsChartQuery (queryMatch, 0)
        var b64 = btoa(JSON.stringify(query))
        var url = window.bobNode + b64
        requests.push(url)
        urlType[url] = 'base'
        // end get vanilla protocol count

        // get MAP app (i = 3) count
        var queryMatch = {}
        queryMatch['$and'] = []
        queryMatch['$and'].push({"out.tape.cell": {"$all": [{"$elemMatch": {"i": 2, "s": "app"}}, {"$elemMatch": {"i": 3, "s": {"$exists": true, "$ne": ""}}}]}})
        queryMatch['$and'].push({'blk.t': {'$gte': beginTimestamp, '$lte': endTimestamp}})
        var query = getActionsChartQuery (queryMatch, 3)
        var b64 = btoa(JSON.stringify(query))
        var url = window.bobNode + b64
        requests.push(url)
        urlType[url] = 'mapApp'
        // end get MAP app (i = 3) count

        // get MAP app (i = 15) count
        var queryMatch = {}
        queryMatch['$and'] = []
        queryMatch['$and'].push({"out.tape.cell": {"$all": [{"$elemMatch": {"i": 14, "s": "app"}}, {"$elemMatch": {"i": 15, "s": {"$exists": true, "$ne": ""}}}]}})
        queryMatch['$and'].push({'blk.t': {'$gte': beginTimestamp, '$lte': endTimestamp}})
        var query = getActionsChartQuery (queryMatch, 15)
        var b64 = btoa(JSON.stringify(query))
        var url = window.bobNode + b64
        requests.push(url)
        urlType[url] = 'mapApp'
        // end get MAP app (i = 15) count

        // get MAP app (i = 17) count
        var queryMatch = {}
        queryMatch['$and'] = []
        queryMatch['$and'].push({"out.tape.cell": {"$all": [{"$elemMatch": {"i": 16, "s": "app"}}, {"$elemMatch": {"i": 17, "s": {"$exists": true, "$ne": ""}}}]}})
        queryMatch['$and'].push({'blk.t': {'$gte': beginTimestamp, '$lte': endTimestamp}})
        var query = getActionsChartQuery (queryMatch, 17)
        var b64 = btoa(JSON.stringify(query))
        var url = window.bobNode + b64
        requests.push(url)
        urlType[url] = 'mapApp'
        // end get MAP app (i = 17) count

        // get "run" app count
        var queryMatch = {}
        queryMatch['$and'] = []
        queryMatch['$and'].push({"out.tape.cell": {"$all": [{"$elemMatch": {"i": 0, "s": "run"}}, {"$elemMatch": {"i": 2, "s": {"$exists": true, "$ne": ""}}}]}})
        queryMatch['$and'].push({'blk.t': {'$gte': beginTimestamp, '$lte': endTimestamp}})
        var query = getActionsChartQuery (queryMatch, 2)
        var b64 = btoa(JSON.stringify(query))
        var url = window.bobNode + b64
        requests.push(url)
        urlType[url] = 'run'
        // end get "run" app count
      }
      let header
      if (window.bitdbApiKey) {
        header = {
          headers: { key: window.bitdbApiKey }
        }
      }

      let promises = [];
      for (let i = 0; i < requests.length; i++) {
          promises.push(getPromise(requests[i], header));
      }

      let chartData = {}
      Promise.all(promises)
        .then((...args) => {
          for (let i = 0; i < args.length; i++) {
            // debug purpose
            if (args[i] !== 'undefined')
            for (let j = 0; j < args[i].length; j++) {
              var dataJson = args[i][j].data
              if (dataJson !== 'undefined' && dataJson.c !== 'undefined')
              for (let index = 0; index < dataJson.c.length; ++index) {
                const base64Id = dataJson.c[index]['_id']
                let itemId = atob(base64Id)
                let itemName = ''
                if (protocols[base64Id] !== undefined) {
                  itemName = protocols[base64Id].name
                } else if (base64Id.length <= 6) {
                  itemName = itemId + ' (' + base64Id + ')'
                } else {
                  itemName = itemId
                }
                if (chartData[itemName] !== undefined) {
                  chartData[itemName]['count'] = chartData[itemName]['count'] + dataJson.c[index]['count']
                  if (!(chartData[itemName]['base64'].includes(base64Id))) {
                    chartData[itemName]['base64'].push(base64Id)
                  }
                  if (dataJson.c[index]['count'] > chartData[itemName]['count']) {
                    chartData[itemName]['type'] = urlType[args[i][j].url]
                  }
                } else {
                  chartData[itemName] = {}
                  chartData[itemName]['count'] = dataJson.c[index]['count']
                  chartData[itemName]['base64'] = []
                  chartData[itemName]['base64'].push(base64Id)
                  chartData[itemName]['itemId'] = itemId.replace(/[^0-9a-zA-Z\.@]/g,"")
                  chartData[itemName]['type'] = urlType[args[i][j].url]
                }
                // B protocol names population
                let prefix = itemId
                if (!(bitcomPrefixes.includes(prefix)) && protocols[prefix] === undefined) {
                  try {
                    bchaddr.isLegacyAddress(prefix)
                    bitcomPrefixes.push(prefix)
                  } catch (e) {
                  }
                }
              }
            }
          }
          for (var k in chartData){
            if (chartData.hasOwnProperty(k)) {
              chartDataUnordered.push([k, chartData[k]['count'], chartData[k]['base64'], chartData[k]['itemId'], chartData[k]['type']])
            }
          }
          chartDataUnordered.sort((a, b) => parseFloat(b[1]) - parseFloat(a[1]))
          var dummyChartObj = {}
          dummyChartObj.chartData = JSON.parse(JSON.stringify(chartDataUnordered));
          getBitcomProtocols().then(function() {
            for (let key in bitcomProtocols) {
              if (!bitcomProtocols.hasOwnProperty(key)) continue;
              for (let ii = 0; ii < dummyChartObj.chartData.length; ii++) {
                if (dummyChartObj.chartData[ii][0] === key) {
                  dummyChartObj.chartData[ii][0] = bitcomProtocols[key]['name']
                }
              }
            }
            chartDataUnordered = JSON.parse(JSON.stringify(dummyChartObj.chartData))
            populateRankings()
          })
        })
        .catch(error => {
          document.getElementById("loading").style.display = "none";
          document.getElementById("error").style.display = "block";
          document.getElementById("loaded").style.display = "none";
          console.log(error)
        })
    }
    var populateRankings = function () {
      chartDataFull = chartDataUnordered
      chartDataSliced = chartDataUnordered.slice(0, parseInt(itemsOnChart))
      // draw chart
      var chartDataset = []
      var chartLabels = []
      for (let i = 0; i < chartDataSliced.length; i++) {
        chartDataset.push(chartDataSliced[i][1])
        chartLabels.push(chartDataSliced[i][0])
      }
      var dataset = {"data": chartDataset, "backgroundColor": window.colors[1].slice(0, parseInt(itemsOnChart)), "label": "Ranking by performed actions"}
      myChart.config.data.datasets.push(dataset)
      myChart.config.data.labels = chartLabels
      myChart.update();
      //populate table
      rankingTable("tableContent", chartDataFull, window.colors[1])
      // show loaded
      document.getElementById("loading").style.display = "none";
      document.getElementById("error").style.display = "none";
      document.getElementById("loaded").style.display = "grid";
    }

    // get actions chart data
    getActionsChartData()
  })
</script>
</body>
</html>
